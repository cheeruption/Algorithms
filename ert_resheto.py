#import cProfile
#import timeit

idx = int(input('Введите номер простого числа: '))
#idx = 10000

def ert_idx(pos):
    '''
    Функция возвращает значение простого числа, которое находится на
    indx-й позиции относительно ряда простых чисел (начиная с 2).
    '''
    n = pos * 15 #предполагаем приблизительное местонахождение числа
    b = []
    while len(b)<pos:
        a = [0] * n  # создание массива с n количеством элементов
        for i in range(n):  # заполнение массива ...
            a[i] = i  # значениями от 0 до n-1

        # вторым элементом является единица, которую не считают простым числом
        # забиваем ее нулем.
        a[1] = 0
        b = []

        m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
        while m < n:  # перебор всех элементов до заданного числа
            if a[m] != 0:  # если он не равен нулю, то
                j = m * 2  # увеличить в два раза (текущий элемент простое число)
                while j < n:
                    a[j] = 0  # заменить на 0
                    j = j + m  # перейти в позицию на m больше
            m += 1

        # вывод простых чисел на экран (может быть реализован как угодно)

        for i in a:
            if a[i] != 0:
                b.append(a[i])
        n = 2 * n
    del a
    return(b[pos-1])


print('Простое число под номером {} равняется'.format(idx),ert_idx(idx))


#cProfile.run('ert_idx(10000)')
#         1    0.001    0.001    0.001    0.001 ert_resheto.py:7(ert_idx) (индекс = 100)
#         1    0.014    0.014    0.014    0.014 ert_resheto.py:7(ert_idx) (индекс = 1000)
#         1    0.130    0.130    0.132    0.132 ert_resheto.py:7(ert_idx) (индекст = 10000)


#print(timeit.timeit('main()'))
# 100000000 loops, best of 3: 0.0153 usec per loop (индекс = 100)
# 100000000 loops, best of 3: 0.0149 usec per loop (индекс = 1000)
# 100000000 loops, best of 3: 0.015 usec per loop (индекс = 10000)